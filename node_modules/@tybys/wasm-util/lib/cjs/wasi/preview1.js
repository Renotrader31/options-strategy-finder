"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WASI = void 0;
const webassembly_1 = require("../webassembly");
const path_1 = require("./path");
const types_1 = require("./types");
const fd_1 = require("./fd");
const error_1 = require("./error");
const util_1 = require("./util");
const rights_1 = require("./rights");
const memory_1 = require("../memory");
const jspi_1 = require("../jspi");
function copyMemory(targets, src) {
    if (targets.length === 0 || src.length === 0)
        return 0;
    let copied = 0;
    let left = src.length - copied;
    for (let i = 0; i < targets.length; ++i) {
        const target = targets[i];
        if (left < target.length) {
            target.set(src.subarray(copied, copied + left), 0);
            copied += left;
            left = 0;
            return copied;
        }
        target.set(src.subarray(copied, copied + target.length), 0);
        copied += target.length;
        left -= target.length;
    }
    return copied;
}
const _memory = new WeakMap();
const _wasi = new WeakMap();
const _fs = new WeakMap();
function getMemory(wasi) {
    return _memory.get(wasi);
}
function getFs(wasi) {
    const fs = _fs.get(wasi);
    if (!fs)
        throw new Error('filesystem is unavailable');
    return fs;
}
function handleError(err) {
    if (err instanceof error_1.WasiError) {
        if (process.env.NODE_ENV !== 'production') {
            console.warn(err);
        }
        return err.errno;
    }
    switch (err.code) {
        case 'ENOENT': return types_1.WasiErrno.ENOENT;
        case 'EBADF': return types_1.WasiErrno.EBADF;
        case 'EINVAL': return types_1.WasiErrno.EINVAL;
        case 'EPERM': return types_1.WasiErrno.EPERM;
        case 'EPROTO': return types_1.WasiErrno.EPROTO;
        case 'EEXIST': return types_1.WasiErrno.EEXIST;
        case 'ENOTDIR': return types_1.WasiErrno.ENOTDIR;
        case 'EMFILE': return types_1.WasiErrno.EMFILE;
        case 'EACCES': return types_1.WasiErrno.EACCES;
        case 'EISDIR': return types_1.WasiErrno.EISDIR;
        case 'ENOTEMPTY': return types_1.WasiErrno.ENOTEMPTY;
        case 'ENOSYS': return types_1.WasiErrno.ENOSYS;
    }
    throw err;
}
function defineName(name, f) {
    Object.defineProperty(f, 'name', { value: name });
    return f;
}
function tryCall(f, wasi, args) {
    let r;
    try {
        r = f.apply(wasi, args);
    }
    catch (err) {
        return handleError(err);
    }
    if ((0, util_1.isPromiseLike)(r)) {
        return r.then(_ => _, handleError);
    }
    return r;
}
function syscallWrap(self, name, f) {
    let debug = false;
    const NODE_DEBUG_NATIVE = (() => {
        try {
            return process.env.NODE_DEBUG_NATIVE;
        }
        catch (_) {
            return undefined;
        }
    })();
    if (typeof NODE_DEBUG_NATIVE === 'string' && NODE_DEBUG_NATIVE.split(',').includes('wasi')) {
        debug = true;
    }
    return debug
        ? defineName(name, function () {
            const args = Array.prototype.slice.call(arguments);
            let debugArgs = [`${name}(${Array.from({ length: arguments.length }).map(() => '%d').join(', ')})`];
            debugArgs = debugArgs.concat(args);
            console.debug.apply(console, debugArgs);
            return tryCall(f, self, args);
        })
        : defineName(name, function () {
            return tryCall(f, self, arguments);
        });
}
function resolvePathSync(fs, fileDescriptor, path, flags) {
    let resolvedPath = (0, path_1.resolve)(fileDescriptor.realPath, path);
    if ((flags & 1) === 1) {
        try {
            resolvedPath = fs.readlinkSync(resolvedPath);
        }
        catch (err) {
            if (err.code !== 'EINVAL' && err.code !== 'ENOENT') {
                throw err;
            }
        }
    }
    return resolvedPath;
}
async function resolvePathAsync(fs, fileDescriptor, path, flags) {
    let resolvedPath = (0, path_1.resolve)(fileDescriptor.realPath, path);
    if ((flags & 1) === 1) {
        try {
            resolvedPath = await fs.promises.readlink(resolvedPath);
        }
        catch (err) {
            if (err.code !== 'EINVAL' && err.code !== 'ENOENT') {
                throw err;
            }
        }
    }
    return resolvedPath;
}
// eslint-disable-next-line spaced-comment
const encoder = /*#__PURE__*/ new TextEncoder();
// eslint-disable-next-line spaced-comment
const decoder = /*#__PURE__*/ new TextDecoder();
const INT64_MAX = (BigInt(1) << BigInt(63)) - BigInt(1);
function readStdin() {
    const value = window.prompt();
    if (value === null)
        return new Uint8Array();
    const buffer = new TextEncoder().encode(value + '\n');
    return buffer;
}
function validateFstFlagsOrReturn(flags) {
    return (Boolean((flags) & ~(types_1.WasiFstFlag.SET_ATIM | types_1.WasiFstFlag.SET_ATIM_NOW |
        types_1.WasiFstFlag.SET_MTIM | types_1.WasiFstFlag.SET_MTIM_NOW)) ||
        ((flags) & (types_1.WasiFstFlag.SET_ATIM | types_1.WasiFstFlag.SET_ATIM_NOW)) ===
            (types_1.WasiFstFlag.SET_ATIM | types_1.WasiFstFlag.SET_ATIM_NOW) ||
        ((flags) & (types_1.WasiFstFlag.SET_MTIM | types_1.WasiFstFlag.SET_MTIM_NOW)) ===
            (types_1.WasiFstFlag.SET_MTIM | types_1.WasiFstFlag.SET_MTIM_NOW));
}
class WASI {
    constructor(args, env, fds, asyncFs, fs, asyncify) {
        this.args_get = syscallWrap(this, 'args_get', function (argv, argv_buf) {
            argv = Number(argv);
            argv_buf = Number(argv_buf);
            if (argv === 0 || argv_buf === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { HEAPU8, view } = getMemory(this);
            const wasi = _wasi.get(this);
            const args = wasi.args;
            for (let i = 0; i < args.length; ++i) {
                const arg = args[i];
                view.setInt32(argv, argv_buf, true);
                argv += 4;
                const data = encoder.encode(arg + '\0');
                HEAPU8.set(data, argv_buf);
                argv_buf += data.length;
            }
            return types_1.WasiErrno.ESUCCESS;
        });
        this.args_sizes_get = syscallWrap(this, 'args_sizes_get', function (argc, argv_buf_size) {
            argc = Number(argc);
            argv_buf_size = Number(argv_buf_size);
            if (argc === 0 || argv_buf_size === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { view } = getMemory(this);
            const wasi = _wasi.get(this);
            const args = wasi.args;
            view.setUint32(argc, args.length, true);
            view.setUint32(argv_buf_size, encoder.encode(args.join('\0') + '\0').length, true);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.environ_get = syscallWrap(this, 'environ_get', function (environ, environ_buf) {
            environ = Number(environ);
            environ_buf = Number(environ_buf);
            if (environ === 0 || environ_buf === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { HEAPU8, view } = getMemory(this);
            const wasi = _wasi.get(this);
            const env = wasi.env;
            for (let i = 0; i < env.length; ++i) {
                const pair = env[i];
                view.setInt32(environ, environ_buf, true);
                environ += 4;
                const data = encoder.encode(pair + '\0');
                HEAPU8.set(data, environ_buf);
                environ_buf += data.length;
            }
            return types_1.WasiErrno.ESUCCESS;
        });
        this.environ_sizes_get = syscallWrap(this, 'environ_sizes_get', function (len, buflen) {
            len = Number(len);
            buflen = Number(buflen);
            if (len === 0 || buflen === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { view } = getMemory(this);
            const wasi = _wasi.get(this);
            view.setUint32(len, wasi.env.length, true);
            view.setUint32(buflen, encoder.encode(wasi.env.join('\0') + '\0').length, true);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.clock_res_get = syscallWrap(this, 'clock_res_get', function (id, resolution) {
            resolution = Number(resolution);
            if (resolution === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { view } = getMemory(this);
            switch (id) {
                case types_1.WasiClockid.REALTIME:
                    view.setBigUint64(resolution, BigInt(1000000), true);
                    return types_1.WasiErrno.ESUCCESS;
                case types_1.WasiClockid.MONOTONIC:
                case types_1.WasiClockid.PROCESS_CPUTIME_ID:
                case types_1.WasiClockid.THREAD_CPUTIME_ID:
                    view.setBigUint64(resolution, BigInt(1000), true);
                    return types_1.WasiErrno.ESUCCESS;
                default: return types_1.WasiErrno.EINVAL;
            }
        });
        this.clock_time_get = syscallWrap(this, 'clock_time_get', function (id, _percision, time) {
            time = Number(time);
            if (time === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const { view } = getMemory(this);
            switch (id) {
                case types_1.WasiClockid.REALTIME:
                    view.setBigUint64(time, BigInt(Date.now()) * BigInt(1000000), true);
                    return types_1.WasiErrno.ESUCCESS;
                case types_1.WasiClockid.MONOTONIC:
                case types_1.WasiClockid.PROCESS_CPUTIME_ID:
                case types_1.WasiClockid.THREAD_CPUTIME_ID: {
                    const t = performance.now() / 1000;
                    const s = Math.trunc(t);
                    const ms = Math.floor((t - s) * 1000);
                    const result = BigInt(s) * BigInt(1000000000) + BigInt(ms) * BigInt(1000000);
                    view.setBigUint64(time, result, true);
                    return types_1.WasiErrno.ESUCCESS;
                }
                default: return types_1.WasiErrno.EINVAL;
            }
        });
        this.fd_advise = syscallWrap(this, 'fd_advise', function (_fd, _offset, _len, _advice) {
            return types_1.WasiErrno.ENOSYS;
        });
        this.fd_fdstat_get = syscallWrap(this, 'fd_fdstat_get', function (fd, fdstat) {
            fdstat = Number(fdstat);
            if (fdstat === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const wasi = _wasi.get(this);
            const fileDescriptor = wasi.fds.get(fd, BigInt(0), BigInt(0));
            const { view } = getMemory(this);
            view.setUint16(fdstat, fileDescriptor.type, true);
            view.setUint16(fdstat + 2, 0, true);
            view.setBigUint64(fdstat + 8, fileDescriptor.rightsBase, true);
            view.setBigUint64(fdstat + 16, fileDescriptor.rightsInheriting, true);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.fd_fdstat_set_flags = syscallWrap(this, 'fd_fdstat_set_flags', function (_fd, _flags) {
            return types_1.WasiErrno.ENOSYS;
        });
        this.fd_fdstat_set_rights = syscallWrap(this, 'fd_fdstat_set_rights', function (fd, rightsBase, rightsInheriting) {
            const wasi = _wasi.get(this);
            const fileDescriptor = wasi.fds.get(fd, BigInt(0), BigInt(0));
            if ((rightsBase | fileDescriptor.rightsBase) > fileDescriptor.rightsBase) {
                return types_1.WasiErrno.ENOTCAPABLE;
            }
            if ((rightsInheriting | fileDescriptor.rightsInheriting) >
                fileDescriptor.rightsInheriting) {
                return types_1.WasiErrno.ENOTCAPABLE;
            }
            fileDescriptor.rightsBase = rightsBase;
            fileDescriptor.rightsInheriting = rightsInheriting;
            return types_1.WasiErrno.ESUCCESS;
        });
        this.fd_prestat_get = syscallWrap(this, 'fd_prestat_get', function (fd, prestat) {
            prestat = Number(prestat);
            if (prestat === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const wasi = _wasi.get(this);
            let fileDescriptor;
            try {
                fileDescriptor = wasi.fds.get(fd, BigInt(0), BigInt(0));
            }
            catch (err) {
                if (err instanceof error_1.WasiError)
                    return err.errno;
                throw err;
            }
            if (fileDescriptor.preopen !== 1)
                return types_1.WasiErrno.EINVAL;
            const { view } = getMemory(this);
            // preopen type is dir(0)
            view.setUint32(prestat, 0, true);
            view.setUint32(prestat + 4, encoder.encode(fileDescriptor.path).length, true);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.fd_prestat_dir_name = syscallWrap(this, 'fd_prestat_dir_name', function (fd, path, path_len) {
            path = Number(path);
            path_len = Number(path_len);
            if (path === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            const wasi = _wasi.get(this);
            const fileDescriptor = wasi.fds.get(fd, BigInt(0), BigInt(0));
            if (fileDescriptor.preopen !== 1)
                return types_1.WasiErrno.EBADF;
            const buffer = encoder.encode(fileDescriptor.path);
            const size = buffer.length;
            if (size > path_len)
                return types_1.WasiErrno.ENOBUFS;
            const { HEAPU8 } = getMemory(this);
            HEAPU8.set(buffer, path);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.fd_seek = syscallWrap(this, 'fd_seek', function (fd, offset, whence, newOffset) {
            newOffset = Number(newOffset);
            if (newOffset === 0) {
                return types_1.WasiErrno.EINVAL;
            }
            if (fd === 0 || fd === 1 || fd === 2)
                return types_1.WasiErrno.ESUCCESS;
            const wasi = _wasi.get(this);
            const fileDescriptor = wasi.fds.get(fd, types_1.WasiRights.FD_SEEK, BigInt(0));
            const r = fileDescriptor.seek(offset, whence);
            const { view } = getMemory(this);
            view.setBigUint64(newOffset, r, true);
            return types_1.WasiErrno.ESUCCESS;
        });
        this.fd_tell = syscallWrap(this, 'fd_tell', function (fd, offset) {
            const wasi = _wasi.get(this);
            const fileDescriptor = wasi.fds.get(fd, types_1.WasiRights.FD_TELL, BigInt(0));
            const pos = BigInt(fileDescriptor.pos);
            const { view } = getMemory(this);
            view.setBigUint64(Number(offset), pos, true);
            return types_1.WasiErrno.ESUCCESS;
        });
    